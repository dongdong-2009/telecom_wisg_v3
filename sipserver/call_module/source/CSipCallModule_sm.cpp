/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : CSipCallModule_sm.sm
 */

/*********************************************************************
 * Copyright (c)2010-2012, by BUPT
 * All rights reserved.

 * FileName:       CSipCallModule.sm
 * System:         webrtc
 * SubSystem:      gateway
 * Author:         Liu Mingshuan
 * Date:           2012.11.28
 * Version:        1.0
 * Description:
 SipCallModule state machineã

 *
 * Last Modified:
 2013-4-17 add Default state
 By Liu Mingshuan.
 *******************************************************************************/

#include "CSipCallModule.h"
#include "./CSipCallModule_sm.h"

using namespace statemap;

// Static class declarations.
CSipCallModState_IDLE CSipCallModState::IDLE("CSipCallModState::IDLE", 0);
CSipCallModState_CALLPROC CSipCallModState::CALLPROC(
		"CSipCallModState::CALLPROC", 1);
CSipCallModState_RECVUPDATE CSipCallModState::RECVUPDATE(
		"CSipCallModState::RECVUPDATE", 2);

CSipCallModState_MS_CALLPROC_1 CSipCallModState::MS_CALLPROC_1(
		"CSipCallModState::MS_CALLPROC_1", 3);
CSipCallModState_MS_SUCCESS_1 CSipCallModState::MS_SUCCESS_1(
		"CSipCallModState::MS_SUCCESS_1", 4);

CSipCallModState_MS_CALLPROC_2 CSipCallModState::MS_CALLPROC_2(
		"CSipCallModState::MS_CALLPROC_2", 5);
CSipCallModState_MS_SUCCESS_2 CSipCallModState::MS_SUCCESS_2(
		"CSipCallModState::MS_SUCCESS_2", 6);

CSipCallModState_PRACK_STATE CSipCallModState::PRACK_STATE(
		"CSipCallModState::PRACK_STATE", 7);

CSipCallModState_PROCEEDING CSipCallModState::PROCEEDING(
		"CSipCallModState::PROCEEDING", 8);

CSipCallModState_MS_UPDATE_FOR_200OK CSipCallModState::MS_UPDATE_FOR_200OK(
		"CSipCallModState::MS_UPDATE_FOR_200OK", 9);

CSipCallModState_MS_UPDATE_FOR_UPDATE CSipCallModState::MS_UPDATE_FOR_UPDATE(
		"CSipCallModState::MS_UPDATE_FOR_UPDATE", 10);


CSipCallModState_ACTIVE CSipCallModState::ACTIVE("CSipCallModState::ACTIVE", 11);
CSipCallModState_RELEASE CSipCallModState::RELEASE("CSipCallModState::RELEASE",
		12);
CSipCallModState_CLOSED CSipCallModState::CLOSED("CSipCallModState::CLOSED", 13);

void CSipCallModuleState::onInfo(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onUpdate(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onAck(CSipCallModuleContext& context, TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onBye(CSipCallModuleContext& context, TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onCancel(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onInvite(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	Default(context);
	return;
}

void CSipCallModuleState::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	Default(context);
	return;
}

void CSipCallModuleState::Default(CSipCallModuleContext& context) {
	//    throw (
	//        TransitionUndefinedException(
	//            context.getState().getName(),
	//            context.getTransition()));

	return;
}

void CSipCallModState_Default::onInvite(CSipCallModuleContext& context,
		TUniNetMsg* msg) {

	return;
}

void CSipCallModState_Default::onUpdate(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	return;
}

void CSipCallModState_Default::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {

	return;
}

void CSipCallModState_Default::onAck(CSipCallModuleContext& context,
		TUniNetMsg* msg) {

	return;
}

void CSipCallModState_Default::onCancel(CSipCallModuleContext& context,
		TUniNetMsg* msg) {

	return;
}

void CSipCallModState_Default::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg) {

	return;
}

void CSipCallModState_Default::onInfo(CSipCallModuleContext& context,
		TUniNetMsg* msg) {

	return;
}

void CSipCallModState_Default::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	CSipCallModule& ctxt(context.getOwner());

	CSipCallModuleState& endState = context.getState();

	context.clearState();
	try {
		ctxt.endTask();
		context.setState(endState);
	} catch (...) {
		context.setState(endState);
		throw;
	}

	return;
}

void CSipCallModState_IDLE::onInvite(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		ctxt.forwardNoSdpInviteToIMS();
		// ctxt.sendToDispatcher(msg);
		context.setState(CSipCallModState::CALLPROC);
	} catch (...) {
		context.setState(CSipCallModState::CALLPROC);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_CALLPROC::onCancel(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.stopTimer();
		ctxt.sendToDispatcher(msg);
		ctxt.setTimer(SIPCALL_ACK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_CALLPROC::onUpdate(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
//	CSipCallModule& ctxt(context.getOwner());

//	(context.getState()).Exit(context);
//	context.clearState();
	try {
		printf("recv update, unsupported temporarily");
		//ctxt.stopTimer();
		// ctxt.sendToDispatcher(msg);
		// ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		// context.setState(CSipCallModState::RECVUPDATE);
	} catch (...) {
		//context.setState(CSipCallModState::RECVUPDATE);
		throw;
	}
	(context.getState()).Entry(context);

	return;

}

void CSipCallModState_CALLPROC::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	//response from ims
	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isResp1xx(msg)) {
		//    	 ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
		if(true == ctxt.isRespWithSdp(msg)){
			//180 ring and 183 progress with sdp for color ring
			//handle like 200 OK
			printf("receive 18x with sdp\n");
			(context.getState()).Exit(context);
			context.clearState();
			try {
				ctxt.stopTimer();
				ctxt.setIMSbody(msg);
				ctxt.forwardInviteToMS_Web();
				ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
				context.setState(CSipCallModState::MS_CALLPROC_1);
			} catch (...) {
				//context.setState(CSipCallModState::SUCCESS);
				throw;
			}
			(context.getState()).Entry(context);
			
		}
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		
		try {
			ctxt.stopTimer();
			ctxt.sendToDispatcher(msg);
			if (ctxt.isSipCaller()) {
				//	ctxt.sendBackACK(msg);
				// ACK is send automatically by exosip
				context.setState(CSipCallModState::CLOSED);
			} else {
				ctxt.setTimer(SIPCALL_ACK_TIMEOUT);
				context.setState(CSipCallModState::RELEASE);
			}
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.setIMSbody(msg);
			ctxt.forwardInviteToMS_Web();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::MS_CALLPROC_1);
		} catch (...) {
			//context.setState(CSipCallModState::SUCCESS);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		context.setState(CSipCallModState::CLOSED);
		(context.getState()).Entry(context);
	}

	return;
}

void CSipCallModState_CALLPROC::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.handleTimeoutAtCallProcState();
		ctxt.setTimer(SIPCALL_ACK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_RECVUPDATE::onCancel(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.stopTimer();
		ctxt.sendToDispatcher(msg);
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_RECVUPDATE::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	TSipResp * sipResp = (TSipResp *) (msg->msgBody);
	printf("mg update answer %d\n", sipResp->statusCode);
	if (sipResp->body.content.length() == 0) {
		printf("mg update answer %d without sdp\n", sipResp->statusCode);
	}
	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.stopTimer();
		ctxt.sendToDispatcher(msg);
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::CALLPROC);
	} catch (...) {
		context.setState(CSipCallModState::CALLPROC);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_RECVUPDATE::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.handleTimeoutAtCallProcState();
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::CALLPROC);
	} catch (...) {
		context.setState(CSipCallModState::CALLPROC);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_MS_CALLPROC_1::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	//send answer to webrtc
	//change to MS_SUCCESS_1

	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			//收到来自XMS的拒绝消息，要想IMS端发送BYE消息，Web段发送BYE消息
			//对XMS的4XX的ACK响应，由协议栈自动发送
			ctxt.sendBackACK(msg);
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg)) {//XMS返回200 OK，取出其中的sdp，返回 answer给webrtc
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.setConnId_Web(msg);
			ctxt.forward200OKToWeb(msg);
			ctxt.setTimer(SIPCALL_ACK_TIMEOUT);
			context.setState(CSipCallModState::MS_SUCCESS_1);
		} catch (...) {
			//context.setState(CSipCallModState::SUCCESS);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		context.setState(CSipCallModState::CLOSED);
		(context.getState()).Entry(context);
	}
	return;

}


void CSipCallModState_MS_CALLPROC_1::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isByeFromRtc(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardCancelToMS_Web();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::RELEASE);
		} catch (...) {
			context.setState(CSipCallModState::RELEASE);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isByeFromSip(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardByeToMS_Web();
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	}
	return;
}

void CSipCallModState_MS_CALLPROC_1::onCancel(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	//cancel is from webrtc, send to dispatcher
	//send cancel to MS

	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.sendToDispatcher(msg);
		ctxt.forwardCancelToMS_Web();
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}


void CSipCallModState_MS_CALLPROC_1::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {

	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardCancelToMS_Web();
		ctxt.handleTimeoutAtCallProcState();
		ctxt.setTimer(SIPCALL_ACK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}

void CSipCallModState_MS_SUCCESS_1::onAck(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.stopTimer();
		//ctxt.sendToDispatcher(msg);
		ctxt.forwardACKToMS_Web();
		//sendInviteToXMS
		ctxt.forwardInviteToMS_IMS();
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::MS_CALLPROC_2);
	} catch (...) {
		context.setState(CSipCallModState::MS_CALLPROC_2);
		throw;
	}
	(context.getState()).Entry(context);

	return;
}

void CSipCallModState_MS_SUCCESS_1::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isByeFromRtc(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardByeToMS_Web();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::RELEASE);
		} catch (...) {
			context.setState(CSipCallModState::RELEASE);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isByeFromSip(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardByeToMS_Web();
			//ctxt.sendBack200OK(msg);
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		//BYE is from XMS
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			//ctxt.sendBack200OK(msg); 200 OK is auto send by exosip
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	}
	return;
}




void CSipCallModState_MS_SUCCESS_1::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {

	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardCancelToIMS();
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}

void CSipCallModState_MS_CALLPROC_2::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	//response from xms,send ACK to IMS and xms

	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			//收到来自XMS的拒绝消息，要想IMS端发送BYE消息，Web段发送BYE消息
			//对XMS的4XX的ACK响应，由协议栈自动发送
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg) && false == ctxt.checkColorRing()) {
		//XMS返回200 OK，且不是彩铃模式
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.setConnId_IMS(msg);
			ctxt.forwardACKToIMS(msg);
			ctxt.forwardACKToMS_IMS();
			ctxt.forwardJoinInfoToMS();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::MS_SUCCESS_2);
		} catch (...) {
			context.setState(CSipCallModState::MS_SUCCESS_2);
			throw;
		}
		(context.getState()).Entry(context);
	} 
	else if(true == ctxt.isResp2xx(msg) && true == ctxt.checkColorRing()){
		//XMS返回200 OK，且是彩铃模式
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.setConnId_IMS(msg);
			
			//ctxt.forwardPrackToIMS(msg);
			ctxt.forwardACKToMS_IMS();

			ctxt.forwardJoinInfoToMS();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::MS_SUCCESS_2);
		} catch (...) {
			context.setState(CSipCallModState::MS_SUCCESS_2);
			throw;
		}
		(context.getState()).Entry(context);
	}
	else {
		context.setState(CSipCallModState::CLOSED);
		(context.getState()).Entry(context);
	}
	return;
}


void CSipCallModState_MS_CALLPROC_2::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());


	if (true == ctxt.isByeFromRtc(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardCancelToMS_IMS();
			ctxt.forwardByeToMS_Web();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::RELEASE);
		} catch (...) {
			context.setState(CSipCallModState::RELEASE);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isByeFromSip(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardCancelToMS_IMS();
			ctxt.forwardByeToMS_Web();
			//ctxt.sendBack200OK(msg);
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		//BYE is from XMS
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			//ctxt.sendBack200OK(msg); 200 OK is auto send by exosip
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	}
	return;

}


void CSipCallModState_MS_CALLPROC_2::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {

	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardCancelToIMS();
		ctxt.forwardCancelToMS_IMS();

		ctxt.forwardByeToWeb();
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}

void CSipCallModState_MS_SUCCESS_2::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			//收到来自XMS的拒绝消息，要想IMS端发送BYE消息，Web段发送BYE消息
			//对XMS的4XX的ACK响应，由协议栈自动发送
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			//ctxt.sendByeToMS_Web();
			//ctxt.sendByeToMS_IMS();

			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg) && false == ctxt.checkColorRing()) {
	//收到PRACK响应的200 OK
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			context.setState(CSipCallModState::ACTIVE);
		} catch (...) {
			context.setState(CSipCallModState::ACTIVE);
			throw;
		}
		(context.getState()).Entry(context);
	}
	else if(true == ctxt.isResp2xx(msg) && true == ctxt.checkColorRing()){
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.forwardPrackToIMS(msg);
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);

			context.setState(CSipCallModState::PRACK_STATE);
		} catch (...) {
			context.setState(CSipCallModState::PRACK_STATE);
			throw;
		}
		(context.getState()).Entry(context);

	}
	return;

}

void CSipCallModState_MS_SUCCESS_2::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	//timeout for join
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardByeToMS_IMS();

		ctxt.forwardByeToWeb();
		ctxt.forwardByeToIMS();

		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}


void CSipCallModState_PRACK_STATE::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg){
	// 200 OK for JOIN, will send PRACK to IMS
	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			ctxt.sendByeToIMS();
			ctxt.forwardByeToMS_Web();
			ctxt.forwardByeToMS_IMS();
			ctxt.sendByeToWeb();
			//ctxt.sendByeToMS();

			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg)) {
		//200 OK for PRACK; 
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			//ctxt.setTimer(SIPCALL_200OK_TIMEOUT);

			context.setState(CSipCallModState::PROCEEDING);
			
		} catch (...) {
			context.setState(CSipCallModState::PROCEEDING);
			throw;
		}
		(context.getState()).Entry(context);
	} 
	
	return;

}

void CSipCallModState_PRACK_STATE::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	//timeout for join
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardByeToMS_IMS();

		ctxt.forwardByeToWeb();
		ctxt.forwardByeToIMS();

		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}


void CSipCallModState_PROCEEDING::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timemark) {
	//timeout for join
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardByeToMS_IMS();

		ctxt.forwardByeToWeb();
		ctxt.forwardByeToIMS();

		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);

}

void CSipCallModState_PROCEEDING::onResponse(CSipCallModuleContext& context,
		TUniNetMsg * msg) {

	CSipCallModule& ctxt(context.getOwner());
	//语音sdp
	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			
			//ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			ctxt.forwardByeToMS_Web();
			ctxt.forwardByeToMS_IMS();
			//ctxt.sendByeToMS();

			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);

			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg) && true ==  ctxt.isRespWithSdp(msg)) {
	//IMS 返回200 OK 
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.forwardReinviteToMS_IMS(msg);
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::MS_UPDATE_FOR_200OK);
		} catch (...) {
			context.setState(CSipCallModState::MS_UPDATE_FOR_200OK);
			throw;
		}
		(context.getState()).Entry(context);
	} 
	else if(true == ctxt.isResp2xx(msg) && false == ctxt.isRespWithSdp(msg)){
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.forwardACKToIMS(msg);
			
			context.setState(CSipCallModState::ACTIVE);
		} catch (...) {
			context.setState(CSipCallModState::ACTIVE);
			throw;
		}
		(context.getState()).Entry(context);

	}

}

void CSipCallModState_PROCEEDING::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg)
{
	printf("PROCEEDING:: receive Bye msg\n");
	CSipCallModule& ctxt(context.getOwner());
	if (true == ctxt.isByeFromRtc(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardCancelToMS_Web();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::RELEASE);
		} catch (...) {
			context.setState(CSipCallModState::RELEASE);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isByeFromSip(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardByeToMS_Web();
			ctxt.forwardByeToMS_IMS();
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		//BYE FROM XMS
		(context.getState()).Exit(context);
		context.clearState();
		try {
			//ctxt.sendToDispatcher(msg);
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	}
	return;

}


void CSipCallModState_PROCEEDING::onUpdate(CSipCallModuleContext& context,
		TUniNetMsg* msg){

	CSipCallModule& ctxt(context.getOwner());


	context.clearState();
	try {
		ctxt.stopTimer();
		ctxt.forwardReinviteToMS_IMS(msg);
		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::MS_UPDATE_FOR_UPDATE);
	} catch (...) {
		context.setState(CSipCallModState::MS_UPDATE_FOR_UPDATE);
		throw;
	}
	(context.getState()).Entry(context);
}

void CSipCallModState_MS_UPDATE_FOR_200OK::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg)
{

	CSipCallModule& ctxt(context.getOwner());
	//response for UPDATE

	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			ctxt.forwardByeToMS_Web();
			//ctxt.forwardByeToMS_IMS();
			//ctxt.sendByeToMS();

			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);

			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg)) {
	//XMS 200 OK for update
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.forwardACKToMS_IMS();
			ctxt.forwardACKToIMS(msg);
			context.setState(CSipCallModState::ACTIVE);
		} catch (...) {
			context.setState(CSipCallModState::ACTIVE);
			throw;
		}
		(context.getState()).Entry(context);
	} 


}

void CSipCallModState_MS_UPDATE_FOR_200OK::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) 
{
	//timeout for join
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardByeToMS_IMS();

		ctxt.forwardByeToWeb();
		ctxt.forwardByeToIMS();

		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);
}


void CSipCallModState_MS_UPDATE_FOR_200OK::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg)
{
	printf("MS_UPDATE_FOR_200OK :: receive BYE msg\n");
}


void CSipCallModState_MS_UPDATE_FOR_UPDATE::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg)
{

	CSipCallModule& ctxt(context.getOwner());
	//response for UPDATE
	if (true == ctxt.isResp1xx(msg)) {
		//     ctxt.stopTimer();
		//  	 ctxt.sendToDispatcher(msg);
	} else if (true == ctxt.isResp3xx_6xx(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();

			
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			ctxt.forwardByeToMS_Web();
			//ctxt.forwardByeToMS_IMS();
			//ctxt.sendByeToMS();

			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);

			context.setState(CSipCallModState::CLOSED);

		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isResp2xx(msg)) {
	//XMS 200 OK for update
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.stopTimer();
			ctxt.forwardACKToMS_IMS();
			ctxt.forward200OKToIMS(msg);
			context.setState(CSipCallModState::PROCEEDING);
		} catch (...) {
			context.setState(CSipCallModState::PROCEEDING);
			throw;
		}
		(context.getState()).Entry(context);
	}


}

void CSipCallModState_MS_UPDATE_FOR_UPDATE::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) 
{
	//timeout for join
	CSipCallModule& ctxt(context.getOwner());

	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.forwardByeToMS_Web();
		ctxt.forwardByeToMS_IMS();

		ctxt.forwardByeToWeb();
		ctxt.forwardByeToIMS();

		ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
		context.setState(CSipCallModState::RELEASE);
	} catch (...) {
		context.setState(CSipCallModState::RELEASE);
		throw;
	}
	(context.getState()).Entry(context);
}


void CSipCallModState_MS_UPDATE_FOR_UPDATE::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg)
{
	printf("MS_UPDATE_FOR_UPDATE :: receive BYE msg\n");
}




void CSipCallModState_ACTIVE::onInvite(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	CSipCallModuleState& endState = context.getState();

	context.clearState();
	//	if (true == ctxt.isConfReINVITE(msg)){
	//		try {
	//			printf("\n SIP-Side Receive Conf Re-Invite\n");
	//			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
	//			ctxt.sendToDispatcher(msg);
	//			context.setState(CSipCallModState::CALLPROC);
	//		} catch (...) {
	//			context.setState(endState);
	//			throw;
	//		}
	//	} else {
	try {
		ctxt.sendBack488NotAcceptableHere(msg);
		context.setState(endState);
	} catch (...) {
		context.setState(endState);
		throw;
	}
	//}

	return;
}

void CSipCallModState_ACTIVE::onInfo(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	CSipCallModuleState& endState = context.getState();
	context.clearState();

	try {
		ctxt.sendBack200OK(msg);
		ctxt.sendToDispatcher(msg);
		context.setState(CSipCallModState::ACTIVE);
	} catch (...) {
		context.setState(endState);
		throw;
	}
}

void CSipCallModState_ACTIVE::onUpdate(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	CSipCallModuleState& endState = context.getState();
	context.clearState();
	try {
		ctxt.sendBack200OK(msg);
		context.setState(CSipCallModState::ACTIVE);
	} catch (...) {
		context.setState(endState);
		throw;
	}
}

void CSipCallModState_ACTIVE::onBye(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());

	if (true == ctxt.isByeFromRtc(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardByeToMS_IMS();
			ctxt.forwardByeToMS_Web();
			ctxt.setTimer(SIPCALL_200OK_TIMEOUT);
			context.setState(CSipCallModState::RELEASE);
		} catch (...) {
			context.setState(CSipCallModState::RELEASE);
			throw;
		}
		(context.getState()).Entry(context);
	} else if (true == ctxt.isByeFromSip(msg)) {
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.forwardByeToMS_IMS();
			ctxt.forwardByeToMS_Web();
			//ctxt.sendBack200OK(msg);
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	} else {
		//BYE is from XMS
		(context.getState()).Exit(context);
		context.clearState();
		try {
			ctxt.sendToDispatcher(msg);
			ctxt.sendByeToIMS();
			ctxt.sendByeToWeb();
			//ctxt.sendBack200OK(msg); 200 OK is auto send by exosip
			context.setState(CSipCallModState::CLOSED);
		} catch (...) {
			context.setState(CSipCallModState::CLOSED);
			throw;
		}
		(context.getState()).Entry(context);
	}

	return;

}

void CSipCallModState_RELEASE::onAck(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());
	(context.getState()).Exit(context);
	context.clearState();
	try {
		ctxt.stopTimer();
		context.setState(CSipCallModState::CLOSED);
	} catch (...) {
		context.setState(CSipCallModState::CLOSED);
		throw;
	}
	(context.getState()).Entry(context);
	return;
}

void CSipCallModState_RELEASE::onResponse(CSipCallModuleContext& context,
		TUniNetMsg* msg) {
	CSipCallModule& ctxt(context.getOwner());
	(context.getState()).Exit(context);

	context.clearState();
	try {
		ctxt.stopTimer();
		context.setState(CSipCallModState::CLOSED);
	} catch (...) {
		context.setState(CSipCallModState::CLOSED);
		throw;
	}
	(context.getState()).Entry(context);
	return;
}

void CSipCallModState_RELEASE::onTimeOut(CSipCallModuleContext& context,
		TTimeMarkExt timerMark) {
	(context.getState()).Exit(context);

	context.clearState();
	try {
		context.setState(CSipCallModState::CLOSED);
	} catch (...) {
		context.setState(CSipCallModState::CLOSED);
		throw;
	}

	(context.getState()).Entry(context);
	return;
}

void CSipCallModState_CLOSED::Entry(CSipCallModuleContext& context) {
	CSipCallModule& ctxt(context.getOwner());

	ctxt.endTask();

	return;
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
