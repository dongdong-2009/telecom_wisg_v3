/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : CSipMessageModule_sm.sm
 */


/*********************************************************************
 * Copyright (c)2010-2012, by BUPT
 * All rights reserved.

 * FileName:       CSipMessageModule.sm
 * System:         webrtc
 * SubSystem:      gateway
 * Author:         Liu Mingshuan
 * Date:           2012.12.19
 * Version:        1.0
 * Description:
     SipMessageModule state machineã

 *
 * Last Modified:
     2012-12-19 original version
            By Liu Mingshuan.
*******************************************************************************/


#include "CSipMessageModule.h"
#include "./CSipMessageModule_sm.h"

using namespace statemap;

// Static class declarations.
CSipMessageModState_IDLE CSipMessageModState::IDLE("CSipMessageModState::IDLE", 0);
CSipMessageModState_FORWARD CSipMessageModState::FORWARD("CSipMessageModState::FORWARD", 1);
CSipMessageModState_RELEASE CSipMessageModState::RELEASE("CSipMessageModState::RELEASE", 2);

void CSipMessageModuleState::onMessage(CSipMessageModuleContext& context, TUniNetMsg* msg)
{
    Default(context);
    return;
}

void CSipMessageModuleState::onTimeOut(CSipMessageModuleContext& context, TTimeMarkExt timerMark)
{
    Default(context);
    return;
}

void CSipMessageModuleState::Default(CSipMessageModuleContext& context)
{
    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

    return;
}

void CSipMessageModState_IDLE::onMessage(CSipMessageModuleContext& context, TUniNetMsg* msg)
{
    CSipMessageModule& ctxt(context.getOwner());

    if (SIP_MESSAGE == msg->msgName && true == ctxt.isFromSip(msg))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.convertToPlain(msg);
            ctxt.sendToDispatcher(msg);
            ctxt.sendBack200OK(msg);
            ctxt.setTimer(SIPMESSAGE_200OK_TIMEOUT);
            context.setState(CSipMessageModState::FORWARD);
        }
        catch (...)
        {
            context.setState(CSipMessageModState::FORWARD);
            throw;
        }
        (context.getState()).Entry(context);
    }
    else if (SIP_MESSAGE == msg->msgName && true == ctxt.isFromRtc(msg))

    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            ctxt.setTimer(SIPMESSAGE_200OK_TIMEOUT);
            context.setState(CSipMessageModState::FORWARD);
        }
        catch (...)
        {
            context.setState(CSipMessageModState::FORWARD);
            throw;
        }
        (context.getState()).Entry(context);
    }    else
    {
         CSipMessageModState_Default::onMessage(context, msg);
    }

    return;
}

void CSipMessageModState_FORWARD::onMessage(CSipMessageModuleContext& context, TUniNetMsg* msg)
{
    CSipMessageModule& ctxt(context.getOwner());

    if (true == ctxt.isResponse200OK(msg))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.stopTimer();
            context.setState(CSipMessageModState::RELEASE);
        }
        catch (...)
        {
            context.setState(CSipMessageModState::RELEASE);
            throw;
        }
        (context.getState()).Entry(context);
    }
    else
    {
         CSipMessageModState_Default::onMessage(context, msg);
    }

    return;
}

void CSipMessageModState_FORWARD::onTimeOut(CSipMessageModuleContext& context, TTimeMarkExt timerMark)
{

    (context.getState()).Exit(context);
    context.setState(CSipMessageModState::RELEASE);
    (context.getState()).Entry(context);

    return;
}

void CSipMessageModState_RELEASE::Entry(CSipMessageModuleContext& context)

{
    CSipMessageModule& ctxt(context.getOwner());

    ctxt.endTask();
    return;
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
