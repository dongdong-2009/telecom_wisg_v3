/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : CRtcCallModule_sm.sm
 */


/*********************************************************************
 * Copyright (c)2010-2012, by BUPT
 * All rights reserved.

 * FileName:       CRtcCallModule.sm
 * System:         webrtc
 * SubSystem:      gateway
 * Author:         Liu Mingshuan
 * Date:           2012.11.26
 * Version:        1.0
 * Description:
     RtcCallModule state machineã

 *
 * Last Modified:
     2013-4-17 add Default state
            By Liu Mingshuan.
*******************************************************************************/


#include "CRtcCallModule.h"
#include "./CRtcCallModule_sm.h"

using namespace statemap;

// Static class declarations.
CRtcCallModState_IDLE CRtcCallModState::IDLE("CRtcCallModState::IDLE", 0);
CRtcCallModState_OFFER CRtcCallModState::OFFER("CRtcCallModState::OFFER", 1);
CRtcCallModState_ANSWER CRtcCallModState::ANSWER("CRtcCallModState::ANSWER", 2);
CRtcCallModState_ACTIVE CRtcCallModState::ACTIVE("CRtcCallModState::ACTIVE", 3);
CRtcCallModState_SHUTDOWN CRtcCallModState::SHUTDOWN("CRtcCallModState::SHUTDOWN", 4);
CRtcCallModState_CLOSED CRtcCallModState::CLOSED("CRtcCallModState::CLOSED", 5);

void CRtcCallModuleState::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{
    Default(context);
    return;
}

void CRtcCallModuleState::onTimeOut(CRtcCallModuleContext& context, TTimeMarkExt timerMark)
{
    Default(context);
    return;
}

void CRtcCallModuleState::Default(CRtcCallModuleContext& context)
{
    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

    return;
}

void CRtcCallModState_Default::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{
    CRtcCallModule& ctxt(context.getOwner());

//    CRtcCallModuleState& endState = context.getState();

    context.clearState();
    try
    {
        ctxt.endTask();
  //      context.setState(endState);
    }
    catch (...)
    {
    //    context.setState(endState);
        throw;
    }

    return;
}

void CRtcCallModState_Default::onTimeOut(CRtcCallModuleContext& context, TTimeMarkExt timerMark)
{

    CRtcCallModuleState& endState = context.getState();

    context.clearState();
    try
    {
        context.setState(endState);
    }
    catch (...)
    {
        context.setState(endState);
        throw;
    }
    return;
}

void CRtcCallModState_IDLE::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{
    CRtcCallModule& ctxt(context.getOwner());

    if ((RTC_OFFER == msg->msgName))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
			//check where if sip user available
        	if(true == ctxt.checkSipUserAvailable(msg)){

        		ctxt.setTimer(RTC_CONNECTION_TIMEOUT);
        		ctxt.sendToDispatcher(msg);
        		context.setState(CRtcCallModState::OFFER);
        	}
        	else{
				ctxt.sendBackError(ERROR_NOSIP);
				context.setState(CRtcCallModState::CLOSED);
        	}
        }
        catch (...)
        {
            context.setState(CRtcCallModState::OFFER);
        }
    }
    else{
    	context.setState(CRtcCallModState::CLOSED);
    }

    (context.getState()).Entry(context);
    return;
}

void CRtcCallModState_OFFER::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{
    CRtcCallModule& ctxt(context.getOwner());

    if (RTC_ANSWER == msg->msgName)
    {
    	//modified by zhangyadong 2014.7.25 for 180 rings
    	TRtcAnswer* pRtcAnswer = (TRtcAnswer*) (msg->msgBody);
    	if(pRtcAnswer->moreComing == 0){
			(context.getState()).Exit(context);
			context.clearState();
			try
			{
				ctxt.stopTimer();
				ctxt.sendToDispatcher(msg);
				ctxt.setTimer(RTC_CONNECTION_TIMEOUT);
				context.setState(CRtcCallModState::ANSWER);
			}
			catch (...)
			{
				context.setState(CRtcCallModState::ANSWER);
			}
    	}
    	else{
    		//moreComing==1, convert it to 180 rings, state not change
    		ctxt.stopTimer();
    		ctxt.sendToDispatcher(msg);
    		ctxt.setTimer(RTC_CONNECTION_TIMEOUT);
    	}
    }
    else if ((RTC_ERROR == msg->msgName))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            context.setState(CRtcCallModState::CLOSED);
        }
        catch (...)
        {
            context.setState(CRtcCallModState::CLOSED);
            throw;
        }
    }
    else if ((RTC_SHUTDOWN == msg->msgName))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            context.setState(CRtcCallModState::CLOSED);
        }
        catch (...)
        {
            context.setState(CRtcCallModState::OFFER);
            throw;
        }

    }
    else{
    	context.setState(CRtcCallModState::OFFER);
    }


    (context.getState()).Entry(context);
    return;
}

void CRtcCallModState_OFFER::onTimeOut(CRtcCallModuleContext& context, TTimeMarkExt timerMark)
{
    (context.getState()).Exit(context);
    context.setState(CRtcCallModState::CLOSED);
    (context.getState()).Entry(context);

    return;
}

void CRtcCallModState_ANSWER::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{
    CRtcCallModule& ctxt(context.getOwner());

    if (RTC_OK == msg->msgName)
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.stopTimer();
            ctxt.sendToDispatcher(msg);
            context.setState(CRtcCallModState::ACTIVE);
        }
        catch (...)
        {
            context.setState(CRtcCallModState::ACTIVE);
            throw;
        }
    }
    else if ((RTC_ERROR == msg->msgName))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            context.setState(CRtcCallModState::CLOSED);
        }
        catch (...)
        {
            context.setState(CRtcCallModState::CLOSED);
            throw;
        }
    }   
	else if ((RTC_SHUTDOWN == msg->msgName) && true == ctxt.isByeFromSip(msg))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            ctxt.setTimer(RTC_SHUTDOWN_TIMEOUT);
            context.setState(CRtcCallModState::SHUTDOWN);
        }
        catch (...)
        {
            context.setState(CRtcCallModState::SHUTDOWN);
            throw;
        }
    }
    else if ((RTC_SHUTDOWN == msg->msgName) && true == ctxt.isByeFromRtc(msg))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            ctxt.sendBackOK(msg);
            context.setState(CRtcCallModState::CLOSED);
		}
        catch (...)
        {
	    	context.setState(CRtcCallModState::CLOSED);
        }

    }
    else{
    	context.setState(CRtcCallModState::ANSWER);
    }
    (context.getState()).Entry(context);

    return;
}

void CRtcCallModState_ANSWER::onTimeOut(CRtcCallModuleContext& context, TTimeMarkExt timerMark)
{
    CRtcCallModule& ctxt(context.getOwner());

    (context.getState()).Exit(context);
    context.clearState();
    try
    {
        ctxt.stopTimer();
        context.setState(CRtcCallModState::CLOSED);
    }
    catch (...)
    {
        context.setState(CRtcCallModState::CLOSED);
        throw;
    }
    (context.getState()).Entry(context);

    return;
}

void CRtcCallModState_ACTIVE::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{
    CRtcCallModule& ctxt(context.getOwner());

    if ((RTC_SHUTDOWN == msg->msgName) && true == ctxt.isByeFromSip(msg))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            ctxt.setTimer(RTC_SHUTDOWN_TIMEOUT);
            context.setState(CRtcCallModState::SHUTDOWN);
        }
        catch (...)
        {
            context.setState(CRtcCallModState::SHUTDOWN);
        }
    }
    else if ((RTC_SHUTDOWN == msg->msgName) && true == ctxt.isByeFromRtc(msg))
    {
        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.sendToDispatcher(msg);
            ctxt.sendBackOK(msg);
            context.setState(CRtcCallModState::CLOSED);
        }
        catch (...)
        {
	    	context.setState(CRtcCallModState::CLOSED);
        }
    }
    else if(RTC_OFFER == msg->msgName)
    {
    	(context.getState()).Exit(context);
    	context.clearState();
		try
		{
			ctxt.setTimer(RTC_CONNECTION_TIMEOUT);
			ctxt.sendToDispatcher(msg);
			context.setState(CRtcCallModState::OFFER);
		} catch (...)
		{
			context.setState(CRtcCallModState::CLOSED);
		}
    }
    else if(RTC_INFO == msg->msgName)
    {
    	(context.getState()).Exit(context);
    	context.clearState();
    	try
    	{
    		ctxt.sendToDispatcher(msg);
    		context.setState(CRtcCallModState::ACTIVE);
    	} catch (...)
    	{
    		context.setState(CRtcCallModState::CLOSED);
    	}
    }
    else
    {
    	context.setState(CRtcCallModState::ACTIVE);
    }

    (context.getState()).Entry(context);

    return;
}

void CRtcCallModState_SHUTDOWN::onMessage(CRtcCallModuleContext& context, TUniNetMsg* msg)
{

//    if ((RTC_OK == msg->msgName))
//    {
//        (context.getState()).Exit(context);
//        context.setState(CRtcCallModState::CLOSED);
//        (context.getState()).Entry(context);
//    }
//    else if ((RTC_ERROR == msg->msgName))
//    {
//        (context.getState()).Exit(context);
//        context.setState(CRtcCallModState::CLOSED);
//        (context.getState()).Entry(context);
//    }
//    else
//    {
	(context.getState()).Exit(context);
	context.setState(CRtcCallModState::CLOSED);
	(context.getState()).Entry(context);
//    }

    return;
}

void CRtcCallModState_SHUTDOWN::onTimeOut(CRtcCallModuleContext& context, TTimeMarkExt timerMark)
{
    CRtcCallModule& ctxt(context.getOwner());

    (context.getState()).Exit(context);
    context.clearState();
    try
    {
        ctxt.stopTimer();
        context.setState(CRtcCallModState::CLOSED);
    }
    catch (...)
    {
        context.setState(CRtcCallModState::CLOSED);
    }
    (context.getState()).Entry(context);

    return;
}

void CRtcCallModState_CLOSED::Entry(CRtcCallModuleContext& context)

{
    CRtcCallModule& ctxt(context.getOwner());

    ctxt.endTask();
    return;
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
